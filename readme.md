# 协程库
&ensp;&ensp;本项目实现了sylar的协程库，其实现使用了非对称模型，且保证子协程不能再创建新的协程，子协程只能与线程主协程进行切换。

## 协程类
* 在这里，我们对协程设置了三种状态：**就绪、运行和结束**；
    
* 另外每个协程有两种操作：**resume（恢复协程运行）与yield（让出执行权）**；

* 除此之外，需要给协程绑定一个**运行函数**和一个**运行的栈空间**


## 协程调度 
&ensp;&ensp;当有很多协程时，如何把这些协程都消耗掉，这就是协程调度。引入协程调度吼，可以先创建一个协程调度器，把这些要调度的协程传递给调度器，由调度器负责把这些协程一个一个消耗，我们在此处采用“先来先服务”算法。  
* class Scheduler**添加协程调度任务：**
    void schedule(sylar::Fiber::ptr task);
* class Scheduler **执行调度任务：** 
    void run(); // 循环对m_tasks队列中的任务进行resume
* class Scheduler**调度器整体逻辑：**
    
    * 初始化当前线程的主协程
    *  创建调度器
    *  添加调度任务
    *  执行调度任务

* main函数线程里的三种协程：**main函数对应的主协程**（线程启动时的第一个协程）、**调度协程**（由主协程创建并用于调度任务协程的协程）、**待调度的任务协程**；
* **main函数线程里的三种协程的运行顺序**：
    * main函数主协程运行，创建调度器；
    * main函数主协程运行，向调度器添加调度任务；
    * 开始协程调度，main函数主协程让出执行权，切换到调度协程，调度协程从任务队列里按顺序执行所有任务；
    * 每次执行一个任务，调度协程就要让出执行权，再切到该任务的协程里去执行，任务执行结束后，还要切回到调度协程，继续下一个任务的调度；
    * 所有任务都执行完后，调度协程还要让出执行权并切回main函数主协程，保证程序能顺利结束。

**解决单线程环境下caller线程（调度器所在的线程）主协程-调度协程-任务协程之间的上下文切换，是sylar协程调度实现的关键**  
    
* **解决思路**：只需要给每个线程增加一个线程局部变量用于保存调度协程的上下文信息即可。如此，每个线程可以保存三个协程的上下文：**⼀个是当前正在执⾏的协程上下⽂，另⼀个是线程主协程的上下⽂，最后⼀个是调度协程的上下⽂。**有这三个上下文，协程就可以根据自己的身份来选择每次和哪个协程进行交换，具体操作如下：
    *   给协程类增加一个bool类型的成员m_runInScheduler，用于记录该协程是否通过调度器来运行；
    *   创建协程时，根据协程的身份制定对应的协程类型，具体的，只有想让调度器调度的协程的m_runInScheduler为true，线程主协程和线程调度协程都为false；
    *   resume一个协程时，如果这个协程m_runInScheduler为true，表示这个协程参与调度器调度，那他应该和调度协程上下文进行切换；在协程yield时，也可以恢复调度携程的上下文，表示从子协程切换回调度协程；
    *   如果协程的m_runInScheduler为false，表示这个协程不参与调度器调度，那么在resume协程时，直接和线程主协程切换就可以，yield也一样，应该恢复线程主协程的上下文。m_runInScheduler为false的协程上下文切换完全和调度协程无关，可以脱离调度器使用。

* **上下文切换流程**  
**1. Main 到 Scheduler:**  
    *   线程主协程启动调度器，进行上下文切换到调度协程；
    *   调用 `resume`时，`Main`协程保存其上下文，并切换到 `Scheduler` 协程。  

    **2. Scheduler 到 Task:**  
    *   调度协程选择一个任务协程执行，通过`resume`切换到任务协程;
    *   调度协程保存其上下文，并切换到任务协程;
    *   任务协程 `m_runInScheduler = true` ，所以需要与调度协程切换上下文。  

    **3. Task 到 Scheduler：**
    *   任务协程在执行过程中需要等待或完成任务时，通过 `yield` 切换回调度协程;
    *   任务协程保存其上下文，并恢复调度协程的上下文。  

    **4. Scheduler 到 Main:**
    *   当所有任务协程都执行完毕或调度器停止时，通过`yield`切换回主协程;
    *   调度协程保存其上下文，并恢复主协程的上下文。
    
* **调度协程的实现**
    * 内部一个while循环，不断从任务队列取任务并执行，每个被调度器执行的协程在结束时都会回到调度协程；
    * 当任务队列为空时，会进入idle协程，该协程什么也不做，直接调用`yield()`方法让出CPU，由于idle协程仍处于`READY`状态，以便随时响应新的任务，这实际上是一个忙等待，会导致CPU占用了升高；
    * 调度协程周期性检查调度器的停止标志。当检测到停止标志时，调度协程会结束idle协程，并退出自身的`while(true)`循环，从而停止调度过程。

## 协程+IO
&ensp;&ensp;在前边的协程调度模块中，调度器对协程的调度时无条件执行的，在调度器已经启动调度的情况下，任务一旦添加成功，就会排队等待调度器执行，**调度器不支持删除调度任务，并且调度器在正常退出之前一定会执行完全部的调度任务。** IO调度协程直接继承协程调度器实现，还增加了**IO事件调度的功能，支持为fd可读/可写的回调函数。**
&ensp;&ensp;对于IO协程调度来说，每次调度包含一个三元组信息：`<描述符，事件类型（读/写），回调函数>`，在源码中保存在结构体`FdContext`。
&ensp;&ensp;IO协程调度器在idle时会epoll_wait所有注册的fd，如果有fd满⾜条件，epoll_wait返回，从私有数据中拿到fd的上
下⽂信息，并且执⾏其中的回调函数。IO协程调度器⽀持取消事件。取消事件表示不关⼼某个fd的某个事件了，如果某个fd的可读或可写事件都被取消了，那这个fd会从调度器的epoll_wait中删除。
* 在继承类IOManager中改造协程调度器，使其⽀持epoll，并重载tickle和idle，实现通知调度协程和IO协程调度功能:`IOManager::IOManager(size_t threads, bool use_caller, const std::string &name): Scheduler(threads, use_caller, name)`
* `void IOManager::idle()`：对于IO协程调度来说，应阻塞在等待IO事件上，idle退出的时机是epoll_wait返回，对应的操作是tickle或注册的IO事件就绪，调度器⽆调度任务时会阻塞idle协程上，对IO调度器⽽⾔，idle状态应该关注两件事
    * 有没有新的调度任务，对应Schduler::schedule()，如果有新的调度任务，那应该⽴即退出idle状态，并执⾏对应的任务；
    * 关注当前注册的所有IO事件有没有触发，如果有触发，那么应该执⾏IO事件对应的回调函数。
* `int IOManager::addEvent(int fd, Event event, std::function<void()> cb)`：添加事件，如果回调函数为空，则把当前协程当成回调执行体(当该事件触发时，将执行当前正在运行的协程)。
* `bool IOManager::delEvent(int fd, Event event)`：删除事件
* `bool IOManager::cancelEvent(int fd, Event event)`：取消事件
* `bool IOManager::cancelAll(int fd)`：取消所有事件

## 定时器 Timer
* **sylar定时器采用最小堆设计。** 所有定时器根据绝对的超时时间点进行排序，每次取出离当前时间最近的⼀个超时时间点，计算出超时需要等待的时间，然后等待超时。超时时间到后，获取当前的绝对时间点，然后把最⼩堆⾥超时时间点⼩于这个时间点的定时器都收集起来，执⾏它们的回调函数。
* **定时器和IO协程调度器的整合。** IO协程调度器的idle协程会在调度器空闲时阻塞在epoll_wait上，等待IO事件发⽣。加⼊定时器功能后，epoll_wait的超时时间改⽤当前定时器的最⼩超时时间来代替。epoll_wait返回后，根据当前的绝对时间把已超时的所有定时器收集起来，执⾏它们的回调函数。